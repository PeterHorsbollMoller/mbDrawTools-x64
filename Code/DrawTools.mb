'*******************************************************************************
'** 	Created By Peter Horsbøll Møller, Pitney Bowes Business Insight
'** 	Program:	DrawTools
'** 	Modul:	DrawTools.mb
'**
'*******************************************************************************

'-------------------------------------
Include "MapBasic.def"
Include "Enums.def"
Include "Icons.def"
Include "Menu.def"
Include "RibbonControls.def"
'**default constants...
Include "Library\Defaults.def"
'Include "Library\MI_ICONS_X64.def"
'Include "Library\RibbonElements.def"

'-------------------------------------
Include "Library\Types\T_MI_POINT.def"
Include "Library\DATETIMELib.def"
Include "Library\DEBUGLib.def"
Include "Library\ERRORLib.def"
Include "Library\MAPPERLib.def"
Include "Library\MATHLib.def"
Include "Library\OBJLib.def"
Include "Library\OBJECTMZLib.def"
Include "Library\ProgramInfo.def"
Include "Library\RIBBONLib.def"
Include "Library\TABLELib.def"
Include "Library\Dialogs\DLGSelectTable.def"

Include "DrawTools.def"
Include "DLGIsoscelesTrapez.def"
Include "DLGArrow.def"
Include "DLGCreateCell.def"
Include "DLGSetNodeCoordinate.def"
Include "DLGUpdateZMValues.def"
Include "DLGUpdateZMUsingNodes.def"
Include "DLGOffsetXYZ.def"
'Include "ELExtendLines.def"

Declare Sub DTUpdateZMUsingNodesObject_Single
Declare Sub DTUpdateZMUsingNodesColumn_Single

Dim	msIconsFile, msBaseTab As String,
	mnRowIDBasePrev As Integer,
	moBase As Object
'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'	nButtonPadID	ID of buttonpad to add the tools to
'	sButtonPadName	Name of button to add the tools to
'				If ID = 0 then the name will be used, otherwise the ID will used
'**********************************************************************************************''
Sub DTAddToolsToButtonPad(ByVal nButtonPadID As Integer, ByVal sButtonPadName As String)

OnError GoTo ErrorOccured

	If nButtonPadID <> 0 Then
		Alter ButtonPad ID nButtonPadID Add
			Separator
			ToolButton
				Calling DTRegionAdd
				Icon 17	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POLYGON
				HelpMsg "Add extra region to selected region\nAdd to selected region"
				ModifierKeys On
			ToolButton
				Calling DTRegionRemove
				Icon 19	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POLYGON
				HelpMsg "Remove drawn region from selected region\nRemove from selected region"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddNode
				Icon 21	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new point to selected polyline\nAdd point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddStartNode
				Icon 23	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new start point to selected polyline\nAdd start point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddEndNode
				Icon 25	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new end point to selected polyline\nAdd end point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTNodeSetCoordinate
				Icon 25	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Set coordinate for specific node\nSet Node Coordinate"
			PushButton
				Calling DTPolylineremoveStartNode
				Icon 27	File DTGetIconsFile()
				HelpMsg "Remove start point from selected polyline\nRemove start point from selected polyline"
			PushButton
				Calling DTPolylineRemoveEndNode
				Icon 29	File DTGetIconsFile()
				HelpMsg "Remove end point from selected polyline\nRemove end point from selected polyline"
			Separator
			PushButton
				Calling DTCombineIntoNew
				Icon 31	File DTGetIconsFile()
				HelpMsg "Combine selected objects into new object\nCombine selected into new"
			ToolButton
				Calling DTCreateGaps
				Icon 33	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Insert Gaps into the editable layer where clicked\nAdd gaps to the editable layer"
				ModifierKeys On
	Else
		Alter ButtonPad sButtonPadName Add
			Separator
			ToolButton
				Calling DTRegionAdd
				Icon 17	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POLYGON
				HelpMsg "Add extra region to selected region\nAdd to selected region"
				ModifierKeys On
			ToolButton
				Calling DTRegionRemove
				Icon 19	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POLYGON
				HelpMsg "Remove drawn region from selected region\nRemove from selected region"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddNode
				Icon 21	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new point to selected polyline\nAdd point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddStartNode
				Icon 23	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new start point to selected polyline\nAdd start point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTPolylineAddEndNode
				Icon 25	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Add new end point to selected polyline\nAdd end point to selected polyline"
				ModifierKeys On
			ToolButton
				Calling DTNodeSetCoordinate
				Icon 25	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Set coordinate for specific node\nSet Node Coordinate"
			PushButton
				Calling DTPolylineremoveStartNode
				Icon 27	File DTGetIconsFile()
				HelpMsg "Remove start point from selected polyline\nRemove start point from selected polyline"
			PushButton
				Calling DTPolylineRemoveEndNode
				Icon 29	File DTGetIconsFile()
				HelpMsg "Remove end point from selected polyline\nRemove end point from selected polyline"
			Separator
			PushButton
				Calling DTCombineIntoNew
				Icon 31	File DTGetIconsFile()
				HelpMsg "Combine selected objects into new object\nCombine selected into new"
			ToolButton
				Calling DTCreateGaps
				Icon 33	File DTGetIconsFile()
				'Cursor nCorsor File FILE_DLL
				Cursor MI_CURSOR_CROSSHAIR
				DrawMode DM_CUSTOM_POINT
				HelpMsg "Insert Gaps into the editable layer where clicked\nAdd gaps to the editable layer"
				ModifierKeys On
	End If

	Call DTToggleDrawTools

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTAddToolsToButtonPad")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'	nButtonPadID	ID of buttonpad to add the tools to
'	sButtonPadName	Name of button to add the tools to
'				If ID = 0 then the name will be used, otherwise the ID will used
'**********************************************************************************************''
Sub DTAddToolsToRibbon()

Dim	nCtrlIdx As Integer,
	sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName As String

OnError GoTo ErrorOccured

	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_EDIT_GRP
	sSplitButtonName		= BTN_SPATIAL_COMBINE_DROPDOWN	'"CombineDropDown"
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_COMBINE		'"CombineDropDownMenuGroup"

	nCtrlIdx = RBNDropDButtonGroupAddControl("DTCombineIntoNew", "Combine Selected into New", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Combine selected objects into new object.", "Select multiple polygons and make sure you have an editable layer to insert the new object into.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_SMALL, "", ApplicationDirectory$() & "Images\ObjectsCombine_32.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTCombineIntoNew")
	End If


	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_EDIT_GRP
	sSplitButtonName		= BTN_SPATIAL_TRANSFORM_SPLIT
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_TRANSFORM

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTRegionAdd", "Add to Region", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Add extra region to the selected region.", "Select a polygon from the editable layer.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolygonAdd_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POLYGON)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTRegionAdd")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTRegionRemove", "Remove from Region", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Remove drawn region from selected region.", "Select a polygon from the editable layer.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolygonRemove_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POLYGON)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTRegionRemove")
	End If

'	sTabName				= TAB_SPATIAL
'	sGroupName			= TAB_SPATIAL_EDIT_GRP
'	sSplitButtonName		= BTN_SPATIAL_TRANSFORM_SPLIT	'"TransformSplitButton"
'	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_TRANSFORM	'"TransformDropdownMenuGroup"

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTOffsetXYZSelection", "Offset in XYZ", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Offset selected Objects in XYZ Dimension.", "Select objects from the editable layer.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\OffsetXYZ_64.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_LINE)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTOffsetXYZSelection")
	End If


	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_EDIT_GRP
	sSplitButtonName		= BTN_SPATIAL_NODES_SPLIT
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_NODES

'	nCtrlIdx = RBNSplitButtonGroupAddControl("sepNodesSplitButton", "", "", ControlType_ContextMenuSeparator, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTUpdateZMOnSelection", "Update ZM Values", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Update Z and M values on selected objects.", "Make sure you have selected objects from the editable layer.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\UpdateZM_64.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTUpdateZMValuesOnSelection")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTUpdateZMUsingNodesTable", "Update ZM using Nodes", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Update Z and M values on editable layer using a table with nodes.", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\UpdateMZUsingNodes_64.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTUpdateZMUsingNodesTable")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTPolylineAddNode", "Add Node", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Add new node to selected polyline where clicked.", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolylineAddNode_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POINT)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTPolylineAddNode")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTPolylineAddStartNode", "Add Start Node", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Add new start node to selected polyline where clicked.", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolylineAddStartNode_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POINT)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTPolylineAddStartNode")
	End If
	nCtrlIdx = RBNSplitButtonGroupAddControl("DTPolylineAddEndNode", "Add End Node", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Add new end node to selected polyline where clicked.", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolylineAddEndNode_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POINT)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTPolylineAddEndNode")
	End If
	nCtrlIdx = RBNSplitButtonGroupAddControl("DTNodeSetCoordinate", "Set Node Coordinate", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Set coordinate for specific node", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\NodeSetCoordinate_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POINT)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTNodeSetCoordinate")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTPolylineRemoveStartNode", "Remove Start Node", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Remove start node from the selected polyline.", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolylineRemoveStartNode_32.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTPolylineRemoveStartNode")
	End If
	nCtrlIdx = RBNSplitButtonGroupAddControl("DTPolylineRemoveEndNode", "Remove End Node", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Remove end node from the selected polyline.", "Make sure you have selected a polyline from the editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PolylineRemoveEndNode_32.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTPolylineRemoveEndNode")
	End If

'	nCtrlIdx = RBNSplitButtonGroupAddControl("DTSplitPolygonIntoHalf", "Split Polygon in Half", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
'	If nCtrlIdx > 0 Then
'		'Create & Set the button tooltip
'		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Split the selected polygon in half", "Make sure you have an editable layer in your map.")
'		'Set the button icon
'		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\IsoscelesTrapez_32.png")
'		'Set DrawMode
'		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_LINE)
'		'Set Cursor
'		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
'		'Set Custom MapBasic Handle to the button
'		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTSplitPolygonIntoHalf")
'	End If

	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_CREATE_GRP			'SpatialCreateBar
	sSplitButtonName		= BTN_SPATIAL_INSERT_SPLIT		'"SpatialCreateInsertSplitButton"
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_INSERTLINES	'"InsertLinesMenuGroup"

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTDrawAndExtendPolyline", "Extending Polyline", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Draw a polyline that extends to intersection with a objects in another table.", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PLineExtending_64.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POLYLINE)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTDrawAndExtendPolyline")
	End If

	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_CREATE_GRP			'SpatialCreateBar
	sSplitButtonName		= BTN_SPATIAL_INSERT_SPLIT		'"SpatialCreateInsertSplitButton"
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_INSERT_REGIONS	'"InsertRegionsMenuGroup"

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTCreateGaps", "Add Gaps", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Insert gaps from the editable layer where clicked into the editable layer.", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\ObjectsGap_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POINT)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_LRG_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTCreateGaps")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTDrawArrow", "Arrow", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Draw an Arrow", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\Arrows_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_POLYLINE)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTDrawArrow")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTDrawIsoscelesTrapez", "Isosceles Trapezoid", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Draw a Isosceles Trapezoid using direction and size details", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\IsoscelesTrapez_32.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_LINE)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTDrawIsoscelesTrapez")
	End If

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTDrawPointBuffer", "Point Buffer", "", ControlType_ToolButton, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Draw a Point Buffer using size details", "Make sure you have an editable layer in the active map window.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\PointBuffer_64.png")
		'Set DrawMode
		Call RBNControlSetDrawModeIdx(nCtrlIdx, DM_CUSTOM_LINE)
		'Set Cursor
		Call RBNControlSetMICursorIdx(nCtrlIdx, MI_CURSOR_CROSSHAIR, "")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTDrawPointBuffer")
	End If

	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_CREATE_GRP
	sSplitButtonName		= BTN_SPATIAL_CREATE_REGIONS_SPLIT
	sSplitButtonGroupName	= MNU_DROPDOWN_GRP_SPATIAL_REGIONS

'	nCtrlIdx = RBNSplitButtonGroupAddControl("sepNodesSplitButton", "", "", ControlType_ContextMenuSeparator, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)

	nCtrlIdx = RBNSplitButtonGroupAddControl("DTCreateCells", "Create Cell Sectors", "", ControlType_Button, sTabName, sGroupName, sSplitButtonName, sSplitButtonGroupName)
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Create Cells Site Sectors from a table", "")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\Sector_64.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTCreateCells")
	End If


	sTabName				= TAB_SPATIAL
	sGroupName			= TAB_SPATIAL_CREATE_GRP

	nCtrlIdx = RBNGroupInsertControlBefore("DTExtractNodesSelection", "Extract Nodes", "", ControlType_Button, sTabName, sGroupName, "GeoCodeSplitButton")
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Extract Nodes into Nodes Table for the selected polylines/polygons.", "Make sure you have selected at least one object from any table.")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, "", ApplicationDirectory$() & "Images\ExtractNodes_64.png")
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTExtractNodesSelection")
	End If

	nCtrlIdx = RBNGroupInsertControlBefore("DTCreateAnglePointAlong", "Create Angle Node Points", "", ControlType_Button, sTabName, sGroupName, "GeoCodeSplitButton")
	If nCtrlIdx > 0 Then
		'Create & Set the button tooltip
		Call RBNControlSetToolTipIdx(nCtrlIdx, PRGIGetApplicationName(), "Create node points with minimum angle for polygons/polylines in a table.", "")
		'Set the button icon
		Call RBNControlSetIconsIdx(nCtrlIdx, CONTROL_SIZE_LARGE, MI_IMG_SPA_CALCANGLE_16, MI_IMG_SPA_CALCANGLE_32)
		'Set Custom MapBasic Handle to the button
		Call RBNControlSetCustomMBXHandlerIdx(nCtrlIdx, "DTCreateAnglePointAlong")
	End If

	Call DTToggleDrawTools

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTAddToolsToRibbon")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTWinFocusChangedHandler

Dim	nWID As Integer

OnError GoTo ErrorOccured

	Call DTToggleDrawTools
	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTWinFocusChangedHandler")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTWinChangedHandler

OnError GoTo ErrorOccured

	Call DTToggleDrawTools
	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTWinChangedHandler")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTSelChangedHandler

OnError GoTo ErrorOccured

	Call DTToggleDrawTools
	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTSelChangedHandler")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTToggleDrawTools

Dim	nWID, nEditLayerID As Integer

OnError GoTo ErrorOccured

	If NumTables() = 0 Then
		Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCreateGaps", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawArrow", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawIsoscelesTrapez", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTExtractNodesSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCreateAnglePointAlong", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCreateCells", FALSE)
'		Print "A Disabling 'DTDrawAndExtendPolyline'"
		Call RBNGroupEnableControls(  "", "", "DTDrawAndExtendPolyline", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawPointBuffer", FALSE)
		Exit Sub
	Else
		Call RBNGroupEnableControls(  "", "", "DTRegionAdd", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTRegionRemove", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTCreateGaps", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTDrawArrow", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTDrawIsoscelesTrapez", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTExtractNodesSelection", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTCreateAnglePointAlong", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTCreateCells", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTDrawAndExtendPolyline", TRUE)
		Call RBNGroupEnableControls(  "", "", "DTDrawPointBuffer", TRUE)
	End If

	nWID		= FrontWindow()

	If SelectionInfo(SEL_INFO_NROWS) = 0 Then
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTExtractNodesSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
	End If
	If SelectionInfo(SEL_INFO_NROWS) <> 1 Then
		Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
	End If
	If SelectionInfo(SEL_INFO_NROWS) < 2 Then
		Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", FALSE)
	End If

	If nWID = 0 Then
		Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTCreateGaps", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawArrow", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawIsoscelesTrapez", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
'		Print "B Disabling 'DTDrawAndExtendPolyline'"
		Call RBNGroupEnableControls(  "", "", "DTDrawAndExtendPolyline", FALSE)
		Call RBNGroupEnableControls(  "", "", "DTDrawPointBuffer", FALSE)
	Else
		If WindowInfo(nWID, WIN_INFO_TYPE) <> WIN_MAPPER Then
			Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTCreateGaps", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTDrawArrow", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTDrawIsoscelesTrapez", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
'			Print "C Disabling 'DTDrawAndExtendPolyline'"
			Call RBNGroupEnableControls(  "", "", "DTDrawAndExtendPolyline", FALSE)
			Call RBNGroupEnableControls(  "", "", "DTDrawPointBuffer", FALSE)
		Else
			nEditLayerID	= MapperInfo(nWID, MAPPER_INFO_EDIT_LAYER)
			If nEditLayerID < 1 Then
				Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTCombineIntoNew", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTCreateGaps", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTDrawArrow", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTDrawIsoscelesTrapez", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
'				Print "D Disabling 'DTDrawAndExtendPolyline'"
				Call RBNGroupEnableControls(  "", "", "DTDrawAndExtendPolyline", FALSE)
				Call RBNGroupEnableControls(  "", "", "DTDrawPointBuffer", FALSE)
			Else
				If LayerInfo(nWID, nEditLayerID, LAYER_INFO_NAME) <> SelectionInfo(SEL_INFO_TABLENAME) Then
					Call RBNGroupEnableControls(  "", "", "DTRegionAdd", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTRegionRemove", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTPolylineAddNode", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTPolylineAddStartNode", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTPolylineAddEndNode", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTNodeSetCoordinate", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveStartNode", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTPolylineRemoveEndNode", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTUpdateZMOnSelection", FALSE)
'					Call RBNGroupEnableControls(  "", "", "DTUpdateZMUsingNodesTable", FALSE)
					Call RBNGroupEnableControls(  "", "", "DTOffsetXYZSelection", FALSE)
				End If
			End If
		End If
	End If

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTToggleDrawTools")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTRegionAdd

OnError GoTo ErrorOccured

Dim	oDrawn, oExisting As Object

OnError GoTo ErrorOccured

	Set CoordSys Table Selection
	oDrawn	= CommandInfo(CMD_INFO_CUSTOM_OBJ)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_RECT, OBJ_TYPE_ELLIPSE, OBJ_TYPE_ROUNDRECT
			oExisting = ConvertToRegion(oExisting)
		Case OBJ_TYPE_REGION
			'**continue Please
		Case Else
			Note "Please select an area based object to use this tool!"
			Exit Sub
	End Case

	Update Selection
		Set OBJ = Combine(oExisting, oDrawn)

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTRegionAdd")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTRegionRemove

Dim	oDrawn, oExisting As Object

OnError GoTo ErrorOccured

	Set CoordSys Table Selection
	oDrawn	= CommandInfo(CMD_INFO_CUSTOM_OBJ)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_RECT, OBJ_TYPE_ELLIPSE, OBJ_TYPE_ROUNDRECT
			oExisting = ConvertToRegion(oExisting)
		Case OBJ_TYPE_ARC
			oExisting = ConvertToPline(oExisting)
		Case OBJ_TYPE_REGION, OBJ_TYPE_LINE, OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select an area based object to use this tool!"
			Exit Sub
	End Case

	Update Selection
		Set OBJ = Erase(oExisting, oDrawn)

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTRegionRemove")

	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTPolylineAddNode

Dim	oExisting As Object,
	i, nSegment, nNode, nSegmentNearest, nNodeNearest As Integer,
	fX, fY, fShortestDistance, fDistance As Float

OnError GoTo ErrorOccured

'	Set CoordSys Window FrontWindow()
	Set CoordSys Table Selection
	fX	= CommandInfo(CMD_INFO_X)
	fY	= CommandInfo(CMD_INFO_Y)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_LINE
			oExisting = ConvertToPline(oExisting)
		Case OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select a line or a polyline to use this tool!"
			Exit Sub
	End Case

	fShortestDistance	= 1000000	'meters, hoping that the users has clicked nearer than this

	For nSegment = 1 To ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS)
		For i = 1 To 2
			If i = 1 Then
				nNode = 1
			Else
				nNode = ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS + nSegment)
			End If

			fDistance	= Distance(fX, fY, ObjectNodeX(oExisting, nSegment, nNode), ObjectNodeY(oExisting, nSegment, nNode), "m")
			If fDistance < fShortestDistance Then
				fShortestDistance	= fDistance
				nSegmentNearest	= nSegment
				nNodeNearest	= nNode
			End If
		Next
	Next	'nSegment

	If nNodeNearest > 1 Then
		'**Adding a new node after the last - need to add one to the node number
		nNodeNearest		= nNodeNearest + 1
	End If

	Alter Object oExisting
		Node Add Position nSegmentNearest, nNodeNearest ( fX, fY )

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTPolylineAddNode")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTPolylineAddStartNode

Dim	oExisting As Object,
	nSegment, nNode As Integer,
	fX, fY As Float

OnError GoTo ErrorOccured

'	Set CoordSys Window FrontWindow()
	Set CoordSys Table Selection
	fX	= CommandInfo(CMD_INFO_X)
	fY	= CommandInfo(CMD_INFO_Y)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_LINE
			oExisting = ConvertToPline(oExisting)
		Case OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select a line or a polyline to use this tool!"
			Exit Sub
	End Case

	nSegment	= 1
	nNode		= 1

	Alter Object oExisting
		Node Add Position nSegment, nNode ( fX, fY )

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTPolylineAddStartNode")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTPolylineAddEndNode

Dim	oExisting As Object,
	nSegment, nNode As Integer,
	fX, fY As Float

OnError GoTo ErrorOccured

'	Set CoordSys Window FrontWindow()
	Set CoordSys Table Selection
	fX	= CommandInfo(CMD_INFO_X)
	fY	= CommandInfo(CMD_INFO_Y)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_LINE
			oExisting = ConvertToPline(oExisting)
		Case OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select a line or a polyline to use this tool!"
			Exit Sub
	End Case

	nSegment	= ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS)
	nNode	= ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS + nSegment)

	nNode	= nNode + 1
	Alter Object oExisting
		Node Add Position nSegment, nNode ( fX, fY )

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTPolylineAddEndNode")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes
'Parameters:
'
'**********************************************************************************************''
Sub DTNodeSetCoordinate

Dim	oExisting, oPoint As Object,
	nSegment, nNode As Integer,
	fX, fY, fTolerance, fZoom As Float,
	sBaseTab As String

OnError GoTo ErrorOccured

	Set CoordSys Table Selection
	fX		= CommandInfo(CMD_INFO_X)
	fY		= CommandInfo(CMD_INFO_Y)
	oPoint	= CreatePoint(fX, fY)

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_PLINE, OBJ_TYPE_REGION
			'**continue Please
		Case Else
			Note "Please select a polyline or polygon/region to use this tool!"
			Close Table SelectionInfo(SEL_INFO_SELNAME)
			Exit Sub
	End Case

	Set Distance Units "m"
	fZoom		= MapperInfo(FrontWindow(), MAPPER_INFO_ZOOM)
'	fTolerance	= 1	'meters	//TODO: Change the tolerance to depend on the the map zoom, say 1/100 or 1/1000 of the map width
	fTolerance	= fZoom / 100
	If not OBJFindSegmentAndNode(oExisting, oPoint, fTolerance, nSegment, nNode) Then
'		fTolerance	= 10	'meters	//TODO: Change the tolerance to depend on the the map zoom, say 1/100 or 1/1000 of the map width
		fTolerance	= fTolerance * 10
		If not OBJFindSegmentAndNode(oExisting, oPoint, fTolerance, nSegment, nNode) Then

			Note "Try to click a bit closer to the node you want to modify!"
			Close Table SelectionInfo(SEL_INFO_SELNAME)
			Exit Sub
		End If
	End If

	Call DEBUGPrint("DTNodeSetCoordinate, Num Segments: " & FormatNumber$(ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS)))
	Call DEBUGPrint("DTNodeSetCoordinate, Num Nodes: " & FormatNumber$(ObjectInfo(oExisting, OBJ_INFO_NPNTS)))

	sBaseTab	= SelectionInfo(SEL_INFO_TABLENAME)
	If not DLGSetNodeCoordinate(oExisting, nSegment, nNode, TableInfo(sBaseTab, TAB_INFO_SUPPORT_MZ)) Then
		Close Table SelectionInfo(SEL_INFO_SELNAME)
		Exit Sub
	End If

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTNodeSetCoordinate")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter HorsbÃ¸ll MÃ¸ller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTUpdateZMValuesOnSelection

Dim	sQuery As String,
	aObj, aROWID, aValue, aValueZ, aValueM As Alias,
	fValueZ, fValueM As Float,
	oInput As Object,
	nROWID, nUpdateTypeZ, nUpdateTypeM As Integer

OnError GoTo ErrorOccured

	If SystemInfo(SYS_INFO_MIVERSION) < 2300 Then
		Note "This only works with MapInfo v2023 or newer!"
		Exit Sub
	End If

	sQuery	= SelectionInfo(SEL_INFO_SELNAME)
	If Not TableInfo(SelectionInfo(SEL_INFO_TABLENAME), TAB_INFO_SUPPORT_MZ) Then
		Note "Please select records from a table that support MZ values."
		Close Table sQuery
		Exit Sub
	End If

	If Not DLGUpdateZMValues(sQuery) Then
		Close Table sQuery
		Exit Sub
	End If


	aObj		= sQuery & ".OBJ"
	aROWID	= sQuery & ".ROWID"

'	If DLGUZMVUseColumn(VALUE_TYPE_Z) Then
'		aValueZ	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_Z)
'	End If
'	If DLGUZMVUseColumn(VALUE_TYPE_M) Then
'		aValueM	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_M)
'	End If

	If DLGUZMVUpdateValue(VALUE_TYPE_Z) And DLGUZMVUpdateValue(VALUE_TYPE_M) Then
		Call DEBUGPrint("Updating M & Z")
		nUpdateTypeZ	= DLGUZMVGetUpdateType(VALUE_TYPE_Z)
		nUpdateTypeM	= DLGUZMVGetUpdateType(VALUE_TYPE_M)

		If DLGUZMVUseColumn(VALUE_TYPE_Z) And DLGUZMVUseColumn(VALUE_TYPE_M) Then
			aValueZ	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_Z)
			aValueM	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_M)

			Update sQuery
				Set		OBJ = OBJMZUpdateMZValues(aObj, aValueZ, nUpdateTypeZ, aValueM, nUpdateTypeM)
		ElseIf DLGUZMVUseColumn(VALUE_TYPE_M) Then
			fValueZ	= DLGUZMVGetValue(VALUE_TYPE_Z)
			aValueM	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_M)

			Update sQuery
				Set		OBJ = OBJMZUpdateMZValues(aObj, fValueZ, nUpdateTypeZ, aValueM, nUpdateTypeM)
		ElseIf DLGUZMVUseColumn(VALUE_TYPE_Z) Then
			aValueZ	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_Z)
			fValueM	= DLGUZMVGetValue(VALUE_TYPE_M)

			Update sQuery
				Set		OBJ = OBJMZUpdateMZValues(aObj, aValueZ, nUpdateTypeZ, fValueM, nUpdateTypeM)
		Else
			fValueZ	= DLGUZMVGetValue(VALUE_TYPE_Z)
			fValueM	= DLGUZMVGetValue(VALUE_TYPE_M)
			Update sQuery
				Set		OBJ = OBJMZUpdateMZValues(aObj, fValueZ, nUpdateTypeZ, fValueM, nUpdateTypeM)
		End If

	ElseIf DLGUZMVUpdateValue(VALUE_TYPE_M) Then
		Call DEBUGPrint("Updating M only")
		nUpdateTypeM	= DLGUZMVGetUpdateType(VALUE_TYPE_M)

		If DLGUZMVUseColumn(VALUE_TYPE_M) Then
			aValueM	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_M)
			Update sQuery
				Set		OBJ = OBJMZUpdateMValues(aObj, aValueM, nUpdateTypeM)
		Else
			fValueM	= DLGUZMVGetValue(VALUE_TYPE_M)
			Update sQuery
				Set		OBJ = OBJMZUpdateMValues(aObj, fValueM, nUpdateTypeM)
		End If

	ElseIf DLGUZMVUpdateValue(VALUE_TYPE_Z) Then
		Call DEBUGPrint("Updating Z only")
		nUpdateTypeZ	= DLGUZMVGetUpdateType(VALUE_TYPE_Z)

		If DLGUZMVUseColumn(VALUE_TYPE_Z) Then
			aValueZ	= sQuery & "." & DLGUZMVGetColumnName(VALUE_TYPE_Z)
			Update sQuery
				Set		OBJ = OBJMZUpdateZValues(aObj, aValueZ, nUpdateTypeZ)
		Else
			fValueZ	= DLGUZMVGetValue(VALUE_TYPE_Z)
			Update sQuery
				Set		OBJ = OBJMZUpdateZValues(aObj, fValueZ, nUpdateTypeZ)
		End If
	End If

	Close Table sQuery

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMValuesOnSelection")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTPolylineRemoveStartNode

Dim	oExisting As Object,
	nSegment, nNode As Integer,
	fX, fY As Float

OnError GoTo ErrorOccured

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select a polyline to use this tool!"
			Exit Sub
	End Case

	If ObjectInfo(oExisting, OBJ_INFO_NPNTS) < 3 Then
		Note "The selected object has too few nodes. Not possible to remove another node!"
		Exit Sub
	End If

	nSegment	= 1
	nNode	= 1

	Alter Object oExisting
		Node Remove Position nSegment, nNode

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTPolylineRemoveStartNode")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTPolylineRemoveEndNode

Dim	oExisting As Object,
	nSegment, nNode As Integer,
	fX, fY As Float

OnError GoTo ErrorOccured

	Fetch First From Selection
	oExisting	= Selection.OBJ

	Do Case ObjectInfo(oExisting, OBJ_INFO_TYPE)
		Case OBJ_TYPE_PLINE
			'**continue Please
		Case Else
			Note "Please select a line or a polyline to use this tool!"
			Exit Sub
	End Case

	If ObjectInfo(oExisting, OBJ_INFO_NPNTS) < 3 Then
		Note "The selected object has too few nodes. Not possible to remove another node!"
		Exit Sub
	End If

	nSegment	= ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS)
	nNode	= ObjectInfo(oExisting, OBJ_INFO_NPOLYGONS + nSegment)

	Alter Object oExisting
		Node Remove Position nSegment, nNode

	Update Selection
		Set OBJ = oExisting

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTPolylineRemoveEndNode")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTCombineIntoNew

Dim	oNew As Object,
	sTab As String

OnError GoTo ErrorOccured

	sTab	= MAPGetEditLayerName(FrontWindow())
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If

	Create Object As Union
		From SelectionInfo(SEL_INFO_SELNAME)
		Into Variable oNew

	Insert Into sTab (OBJ)
		Values (oNew)

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTCombineIntoNew")
	Call ERRShow()

End Sub


'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTCreateGaps

Dim	sTab As String,
	oPoint, oBuffer As Object,
	fX, fY, fZoom As Float

OnError GoTo ErrorOccured

	Set CoordSys Window FrontWindow()
	fX		= CommandInfo(CMD_INFO_X)
	fY		= CommandInfo(CMD_INFO_Y)
	oPoint 	= CreatePoint(fX, fY)

	sTab	= MAPGetEditLayerName(FrontWindow())
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If

	Set Distance Units "m"
	fZoom	= MapperInfo(FrontWindow(), MAPPER_INFO_ZOOM)
	oBuffer	= CartesianBuffer(oPoint, 24, (fZoom / 4), "m")
	Select * From sTab
		Where OBJ Intersects oBuffer
		Into __GAP__QUERY

	If TableInfo("__GAP__QUERY", TAB_INFO_NROWS) > 1 Then
		Objects Check From __GAP__QUERY Into Table sTab
			Gap 1000 Units "sq m"
	End If

	Close Table __GAP__QUERY

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTCombineIntoNew")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes
'Parameters:
'
'**********************************************************************************************''
Sub DTDrawArrow

Dim	oDrawn, oLineStart, oLineEnd, oBuffer, oArrow, oArrowLine, oArrowTail, oArrowHead, oPoint As Object,
	fStartX, fStartY, fEndX, fEndY As Float,
	nWID, nNumNodes As Integer,
	sTab As String

OnError GoTo ErrorOccured

	nWID = FrontWindow()
	If nWID = 0 Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If
	If Not WindowInfo(nWID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If

	sTab	= MAPGetEditLayerName(nWID)
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If
	Set CoordSys Table sTab

	oDrawn	= CommandInfo(CMD_INFO_CUSTOM_OBJ)

	If not DLGArrow() Then
		Exit Sub
	End If

	oArrow = OBJCartesianCreateArrow(oDrawn, 0.5, DLGAGetBufferResolution(), DLGAGetBufferWidth()
								, DLGAGetArrowType(ARROW_END_HEAD), DLGAGetArrowLengthPct(ARROW_END_HEAD)/100, DLGAGetArrowWidthPct(ARROW_END_HEAD)/100
								, DLGAGetArrowType(ARROW_END_TAIL), DLGAGetArrowLengthPct(ARROW_END_TAIL)/100, DLGAGetArrowWidthPct(ARROW_END_TAIL)/100)

	Insert Into sTab (OBJ) Values (oArrow)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTDrawArrow")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTDrawIsoscelesTrapez

Dim	nWID As Integer,
	fStartX, fStartY, fEndX, fEndY, fDirection, fDistance As Float,
	sTab As String,
	oPoint, oGeometry As Object

OnError GoTo ErrorOccured

	nWID = FrontWindow()
	If nWID = 0 Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If
	If Not WindowInfo(nWID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If

	sTab	= MAPGetEditLayerName(nWID)
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If
	Set CoordSys Table sTab

	fStartX	= CommandInfo(CMD_INFO_X)
	fStartY	= CommandInfo(CMD_INFO_Y)
	fEndX	= CommandInfo(CMD_INFO_X2)
	fEndY	= CommandInfo(CMD_INFO_Y2)

'	Note FormatNumber$(fStartX) & " | " & FormatNumber$(fStartY)

	fDirection	= MATHGetDirection(fStartX, fStartY, fEndX, fEndY)
	fDistance		= Round(CartesianDistance(fStartX, fStartY, fEndX, fEndY, "m"), 0.001)

'	Note FormatNumber$(fDirection) & " | " & FormatNumber$(fDistance)
	If fDistance = -1 Then
		fDistance		= Round(Distance(fStartX, fStartY, fEndX, fEndY, "m"), 0.001)
	End If

	If Not DLGIsoscelesTrapez(fStartX, fStartY, fDirection, fDistance, -1, -1, -1) Then
		Exit Sub
	End If

	oPoint	= CreatePoint(DLGITGetX(), DLGITGetY())
	oGeometry = OBJCreateTrapez(oPoint, DLGITGetDirection(), DLGITGetLength(), DLGITGetWidthAtStart(), DLGITGetWidthAtEnd(), DLGITAddMidPointNode(), DLGITGetCalculationMethod())

	Insert Into sTab (OBJ) Values (oGeometry)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTDrawIsoscelesTrapez")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTSplitPolygonIntoHalf

Dim	oPolygon, oSplitter, oBaseLine, oNode, oPoint1, oPoint2, oLine, arrLines() As Object,
	nWID, nSegment, nNode, nCount, nLine As Integer,
	fXFrom, fYFrom, fXTo, fYTo, fDirection, fDirectionPerp1, fDirectionPerp2, fDistance, fMaxLength As Float

OnError GoTo ErrorOccured

	nWID = FrontWindow()
	If nWID = 0 Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If
	If Not WindowInfo(nWID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If

'	Set CoordSys Window FrontWindow()
	Set CoordSys Table Selection
	fXFrom			= CommandInfo(CMD_INFO_X)
	fYFrom			= CommandInfo(CMD_INFO_Y)
	fXTo				= CommandInfo(CMD_INFO_X2)
	fYTo				= CommandInfo(CMD_INFO_Y2)
	fDirection		= MATHGetDirection(fXFrom, fYFrom, fXTo, fYTo)
	fDirectionPerp1	= IIf(fDirection + 90 > 360, fDirection - 90, fDirection + 90)
	fDirectionPerp2	= IIf(fDirectionPerp1 > 180, fDirectionPerp1 - 180, fDirectionPerp1 + 180)

	Create Pline
		Into Variable oBaseLine
		2 (fXFrom, fYFrom) (fXTo, fYTo)

	Print "Direction: " & fDirection
	Print "Direction Perpedicular: " & fDirectionPerp1

	Fetch First From Selection
	oPolygon	= Selection.OBJ

	Do Case ObjectInfo(oPolygon, OBJ_INFO_TYPE)
		Case OBJ_TYPE_REGION
			'**continue Please
			If Not ObjectInfo(oPolygon, OBJ_INFO_NPOLYGONS) = 1 Then
				Note "Please select a polygon object with just one segment to use this tool!"
				Exit Sub
			End If
		Case Else
			Note "Please select a polygon object to use this tool!"
			Exit Sub
	End Case

	fMaxLength	= Maximum(
					Distance(ObjectGeography(oPolygon, OBJ_GEO_MINX), ObjectGeography(oPolygon, OBJ_GEO_MINY), ObjectGeography(oPolygon, OBJ_GEO_MINX), ObjectGeography(oPolygon, OBJ_GEO_MAXY), "m")
					, Distance(ObjectGeography(oPolygon, OBJ_GEO_MINX), ObjectGeography(oPolygon, OBJ_GEO_MINY), ObjectGeography(oPolygon, OBJ_GEO_MAXX), ObjectGeography(oPolygon, OBJ_GEO_MINY), "m")
					) * 2

	Print "Max Length: " & FormatNumber$(Round(fMaxLength, 0.01)) & " m"

	oPoint1	= OBJCartesianCreatePointAlong(oBaseLine, fDistance, 0)
	oPoint2	= OBJCartesianCreatePointAlong(oBaseLine, fDistance * -1, 0)

	Create Pline
		Into Variable oBaseLine
		2 (CentroidX(oPoint1), CentroidY(oPoint1)) (CentroidX(oPoint2), CentroidY(oPoint2))
		Pen MakePen(2, 3, RED)

	Insert Into WindowInfo(nWID, WIN_INFO_TABLE)
		(OBJ)
		Values (oBaseLine)

	Create Pline
		Into Variable oSplitter
		0
		Pen MakePen(2, 3, RED)

	nSegment = 1
'	For nSegment = 1 To ObjectInfo(oPolygon, OBJ_INFO_NPOLYGONS)
		For nNode = 1 To ObjectInfo(oPolygon, OBJ_INFO_NPOLYGONS + nSegment)
			Print "Node: " & FormatNumber$(nNode)
			oNode 		= CreatePoint(ObjectNodeX(oPolygon, nSegment, nNode), ObjectNodeY(oPolygon, nSegment, nNode))

'			oPoint1	= OBJCartesianCreatePointAlong(oBaseLine, fDistance, fMaxLength)
'			oPoint2	= OBJCartesianCreatePointAlong(oBaseLine, fDistance, fMaxLength * -1)
'			oLine		= CartesianConnectObjects(oBaseLine, oNode, TRUE)

			oPoint1	= CartesianOffset(oNode, fDirectionPerp1, fMaxLength, "m")
			oPoint2	= CartesianOffset(oNode, fDirectionPerp2, fMaxLength, "m")

			Create Pline
				Into Variable oLine
				2 (CentroidX(oPoint1), CentroidY(oPoint1)) (CentroidX(oPoint2), CentroidY(oPoint2))
				Pen MakePen(2, 3, BLUE)

			If oLine Intersects oPolygon Then
				If CartesianObjectLen(Overlap(oLine, oPolygon), "m") > 0.0 Then
				Print "  Length of perp line: " & FormatNumber$(Round(CartesianObjectLen(Overlap(oLine, oPolygon), "m"), 0.01))
					Print "  Adding Line ..."
					oLine	= Overlap(oLine, oPolygon)
					Insert Into WindowInfo(nWID, WIN_INFO_TABLE)
						(OBJ)
						Values (oLine)

					nCount = nCount + 1
					Redim arrLines(nCount)
					arrLines(nCount) = oLine

					Alter Object oSplitter
						Node Add Position 1, nCount (CentroidX(oLine), CentroidY(oLine))
				End If
			End If
		Next
'	For Next

'	For nLine = 0 To ((Int(fMaxLength) + 1) * 2) Step 1
'
'		fDistance	= nLine * 1.00
'		Print "Distance: " & FormatNumber$(Round(fDistance, 0.01)) & " m"
'		oPoint1	= OBJCartesianCreatePointAlong(oBaseLine, fDistance, fMaxLength)
'		oPoint2	= OBJCartesianCreatePointAlong(oBaseLine, fDistance, fMaxLength * -1)
'
'		Create Pline
'			Into Variable oLine
'			2 (CentroidX(oPoint1), CentroidY(oPoint1)) (CentroidX(oPoint2), CentroidY(oPoint2))
'			Pen MakePen(2, 2, BLUE)
'
'		If oLine Intersects oPolygon Then
'			Print "Adding Line ..."
''			Insert Into WindowInfo(nWID, WIN_INFO_TABLE)
''				(OBJ)
''				Values (oLine)
'
'			nCount = nCount + 1
'			Redim arrLines(nCount)
'			arrLines(nCount) = oLine
'
'			oLine	= Overlap(oLine, oPolygon)
'			Alter Object oSplitter
'				Node Add Position 1, nCount (CentroidX(oLine), CentroidY(oLine))
'		End If
'	Next

	Insert Into WindowInfo(nWID, WIN_INFO_TABLE)
		(OBJ)
		Values (oSplitter)

	Close Table SelectionInfo(SEL_INFO_SELNAME)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTSplitPolygonIntoHalf")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'	:
'Return value:
'
'**********************************************************************************************''
Function DTGetIconsFile() As String

OnError GoTo ErrorOccured

	If msIconsFile = "" Then
		msIconsFile	= ApplicationDirectory$() & "DrawTools.dll"
	End If
	DTGetIconsFile = msIconsFile
	Exit Function
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTGetIconsFile")
	Call ERRShow()

End Function

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes Business Insight
'Parameters:
'
'**********************************************************************************************''
Sub DTSetIconsFile(ByVal sFile As String)

OnError GoTo ErrorOccured

	msIconsFile	= sFile
	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTSetIconsFile")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Pitney Bowes
'Parameters:
'
'**********************************************************************************************''
Sub DTCreateAnglePointAlong

Dim	sTab, sNodesTab, sNodesFile As String,
	nMID, nRow, nSegm, nNode As Integer,
	oCur As Object,
	tCur, tPrev, tNext As T_MI_POINT,
	fAnglePrev, fAngleNext, fAngle As Float,
	aObj, aRowID As Alias,
	symCur As Symbol

OnError GoTo ErrorOccured

	sTab = DLGSelectTable(TAB_USE_ALL_MAPPABLE_BUT_IMAGES, "Calculate Node Angles", "Select table to run through", "", FALSE, sTab)
	If sTab = "" Then
		Exit Sub
	End If

	Set CoordSys Table sTab

	sNodesFile	= TableInfo(sTab, TAB_INFO_TABFILE)
	sNodesFile	= Left$(sNodesFile, Len(sNodesFile) - 4) & " Nodes.tab"
	'**Placing the nodes file in a temporary folder
	sNodesFile	= PathToDirectory$(TempFileName$("")) & PathToFileName$(sNodesFile)
	sNodesTab		= PathToTableName$(sNodesFile)


	If TableInfo(sTab, TAB_INFO_TYPE) = TAB_TYPE_RESULT Then
		sNodesFile	= sTab & " Node Angles.tab"
		'**Placing the nodes file in a temporary folder
		sNodesFile = PathToDirectory$(TempFileName$("")) & sNodesFile
	Else
		sNodesFile	= TableInfo(sTab, TAB_INFO_TABFILE)
		sNodesFile	= Left$(sNodesFile, Len(sNodesFile) - 4) & " Node Angles.tab"
		'**Placing the nodes file in a temporary folder
		sNodesFile	= PathToDirectory$(TempFileName$("")) & PathToFileName$(sNodesFile)
	End If

	sNodesTab		= PathToTableName$(sNodesFile)

	If not TABIsOpen(sNodesTab) Then
		Create Table sNodesTab
			( TABLE_NAME		Char(50)
			, RECORD_NO		Integer
			, NODE_NO			Integer
			, MINIMUM_ANGLE	Float
			)
			File sNodesFile
		Create Map For sNodesTab
			Coordsys Table sTab
		Set Table sNodesTab Persist Off
	End If

'	Set Table Redraw Off

	aObj		= sTab & ".OBJ"
	aRowID	= sTab & ".ROWID"
	symCur	= CurrentSymbol()

	Fetch First From sTab
	Do Until EOT(sTab)
		oCur = aObj
		nRow	= aRowID

		If ObjectInfo(oCur, OBJ_INFO_TYPE) In (OBJ_TYPE_PLINE, OBJ_TYPE_REGION) Then
			For nSegm = 1 To ObjectInfo(oCur, OBJ_INFO_NPOLYGONS)
				tPrev.fX	= ObjectNodeX(oCur, nSegm, 1)
				tPrev.fY	= ObjectNodeY(oCur, nSegm, 1)
				tCur.fX	= ObjectNodeX(oCur, nSegm, 2)
				tCur.fY	= ObjectNodeY(oCur, nSegm, 2)

				For nNode = 2 To (ObjectInfo(oCur, OBJ_INFO_NPOLYGONS + nSegm) - 1)
'					tPrev.fX	= ObjectNodeX(oCur, nSegm, (nNode - 1))
'					tPrev.fY	= ObjectNodeY(oCur, nSegm, (nNode - 1))
'					tCur.fX	= ObjectNodeX(oCur, nSegm, nNode)
'					tCur.fY	= ObjectNodeY(oCur, nSegm, nNode)
					tNext.fX	= ObjectNodeX(oCur, nSegm, (nNode + 1))
					tNext.fY	= ObjectNodeY(oCur, nSegm, (nNode + 1))

					fAnglePrev	= MATHGetDirection(tCur.fX, tCur.fY, tPrev.fX, tPrev.fY)
					fAngleNext	= MATHGetDirection(tCur.fX, tCur.fY, tNext.fX, tNext.fY)

'					Print "Node: " & nNode & ": Angle 1: " & FormatNumber$(fAnglePrev) & " - Angle 2: " & FormatNumber$(fAngleNext)

					fAngle		= Maximum(fAnglePrev, fAngleNext) - Minimum(fAnglePrev, fAngleNext)
					fAngle		= Minimum(fAngle, (360 - fAngle))

'					Print "Angle: " & FormatNumber$(fAngle) & " at " & tCur.fX & " | " & tCur.fY

					Insert Into sNodesTab
						(TABLE_NAME, RECORD_NO, NODE_NO, MINIMUM_ANGLE, OBJ)
						Values
						(sTab, nRow, nNode, fAngle, tmipToPointWithStyle(tCur, symCur))

					tPrev.fX	= tCur.fX
					tPrev.fY	= tCur.fY
					tCur.fX	= tNext.fX
					tCur.fY	= tNext.fY
				Next

				If ObjectInfo(oCur, OBJ_INFO_TYPE) = OBJ_TYPE_REGION Then
'					tPrev.fX	= ObjectNodeX(oCur, nSegm, (ObjectInfo(oCur, OBJ_INFO_NPOLYGONS + nSegm) - 1))
'					tPrev.fY	= ObjectNodeY(oCur, nSegm, (ObjectInfo(oCur, OBJ_INFO_NPOLYGONS + nSegm) - 1))
'					tCur.fX	= ObjectNodeX(oCur, nSegm, (ObjectInfo(oCur, OBJ_INFO_NPOLYGONS + nSegm)))
'					tCur.fY	= ObjectNodeY(oCur, nSegm, (ObjectInfo(oCur, OBJ_INFO_NPOLYGONS + nSegm)))
					tNext.fX	= ObjectNodeX(oCur, nSegm, 2)
					tNext.fY	= ObjectNodeY(oCur, nSegm, 2)

					fAnglePrev	= MATHGetDirection(tCur.fX, tCur.fY, tPrev.fX, tPrev.fY)
					fAngleNext	= MATHGetDirection(tCur.fX, tCur.fY, tNext.fX, tNext.fY)

'					Print "Node: 1: Angle 1: " & FormatNumber$(fAnglePrev) & " - Angle 2: " & FormatNumber$(fAngleNext)

					fAngle		= Maximum(fAnglePrev, fAngleNext) - Minimum(fAnglePrev, fAngleNext)
					fAngle		= Minimum(fAngle, (360 - fAngle))

'					Print "Angle: " & FormatNumber$(fAngle) & " at " & tCur.fX & " | " & tCur.fY

					Insert Into sNodesTab
						(TABLE_NAME, RECORD_NO, NODE_NO, MINIMUM_ANGLE, OBJ)
						Values
						(sTab, nRow, 1, fAngle, tmipToPointWithStyle(tCur, symCur))
				End If
			Next
		End If

		Fetch Next From sTab
	Loop

'	Set Table Redraw On

	Call RBNNotificationShow(PRGIGetApplicationName(), "The nodes are stored in the temporary table, " & sNodesTab & ". Rename the table to keep the result. It will not be maintained in your workspace", Notify_Info, 20000)

	nMID = MAPFrontWindow()
	If nMID > 0 Then
		Add Map
			Window nMID Auto
			Layer sNodesTab
		Set Map Window nMID
			Layer sNodesTab
				Label Auto On With MINIMUM_ANGLE
	End If

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTCreateAnglePointAlong")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTExtractNodesSelection

Dim	sQuery, sBaseTab, sNodesFile, sNodesTab As String,
	aRowID, aObj As Alias,
	oSel, oNode As Object,
	nRowID, nSegm, nNode, nMID As Integer,
	fX, fY, fZ, fM As Float,
	bSupportsMZ, bHasM, bHasZ As Logical

OnError GoTo ErrorOccured

	If SelectionInfo(SEL_INFO_NROWS) = 0 Then
		Note "Please select the records that you want to create nodes for!"
		Exit Sub
	End If

	sQuery		= SelectionInfo(SEL_INFO_SELNAME)
	sBaseTab		= SelectionInfo(SEL_INFO_TABLENAME)
	bSupportsMZ	= TableInfo(sBaseTab, TAB_INFO_SUPPORT_MZ)

	sNodesFile	= TableInfo(sBaseTab, TAB_INFO_TABFILE)
	sNodesFile	= Left$(sNodesFile, Len(sNodesFile) - 4) & " Nodes.tab"
	'**Placing the nodes file in a temporary folder
	sNodesFile	= PathToDirectory$(TempFileName$("")) & PathToFileName$(sNodesFile)
	sNodesTab		= PathToTableName$(sNodesFile)

	If TABIsOpen(sNodesTab) Then
		If Not Ask("Output table for nodes already exists:" & Chr$(10) & sNodesTab & Chr$(10) & Chr$(10) & "Do you want to overwrite it or add to it?", "Add to", "Overwrite") Then
			Drop Table sNodesTab
		End If
	End If

	If Not TABIsOpen(sNodesTab) Then
		Create Table sNodesTab
			(
				OBJECT_ID		LargeInt,
				SEGMENT_ID	Integer,
				NODE_ID		Integer,
				X			Float,
				Y			Float,
				Z			Float,
				M			Float,
				NEW_Z		Float,
				NEW_M		Float
			)
			File sNodesFile
		If bSupportsMZ Then
			Create Map For sNodesTab
				Coordsys Table sBaseTab SupportMZ On
		Else
			Create Map For sNodesTab
				Coordsys Table sBaseTab
		End If
		Set Table sNodesTab Persist Off
	End If

	aRowID	= sQuery & ".ROWID"
	aObj		= sQuery & ".OBJ"
	bHasZ	= FALSE
	bHasM	= FALSE

	Set Coordsys Table sBaseTab
	Fetch First From sQuery
	Do Until EOT(sQuery)
		nRowID	= aRowID
		nRowID	= BaseTableRowID(sQuery)
		oSel		= aObj

		If bSupportsMZ Then
			bHasZ	= ObjectInfo(oSel, OBJ_INFO_HAS_Z)
			bHasM	= ObjectInfo(oSel, OBJ_INFO_HAS_M)
		End If

		For nSegm	= 1 To ObjectInfo(oSel, OBJ_INFO_NPOLYGONS)
			For nNode = 1 To ObjectInfo(oSel, OBJ_INFO_NPOLYGONS + nSegm)
				fX		= ObjectNodeX(oSel, nSegm, nNode)
				fY		= ObjectNodeY(oSel, nSegm, nNode)

				oNode	= CreatePoint(fX, fY)

				If bHasZ Then
					fZ		= ObjectNodeZ(oSel, nSegm, nNode)
					oNode	= OBJMZUpdateZValues(oNode, fZ, CALC_TYPE_SET_TO)
				End If
				If bHasM Then
					fM		= ObjectNodeM(oSel, nSegm, nNode)
					oNode	= OBJMZUpdateMValues(oNode, fM, CALC_TYPE_SET_TO)
				End If

				Insert Into sNodesTab
					(OBJECT_ID, SEGMENT_ID, NODE_ID, X, Y, Z, M, OBJ)
					Values (nRowID, nSegm, nNode, fX, fY, fZ, fM, oNode)
			Next
		Next	'nSegm

		Fetch Next From sQuery
	Loop

	Call RBNNotificationShow(PRGIGetApplicationName(), "The nodes are stored in the temporary table, " & sNodesTab & ". Rename the table to keep the result. It will not be maintained in your workspace", Notify_Info, 20000)

	nMID = MAPFrontWindow()
	If nMID > 0 Then
		Add Map
			Window nMID Auto
			Layer sNodesTab
	End If

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTExtractNodesSelection")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTUpdateZMUsingNodesTable

Dim	nMID, nLayer As Integer,
'	nRowIDNodes, nRowID, nSegment, nNode As Integer,
'	fX, fY, fZ, fM As Float,
	sNodesFile, sNodesTab As String
'	aBaseObj As Alias,
'	oNode, oBase As Object

OnError GoTo ErrorOccured

	nMID = FrontWindow()
	If nMID = 0 Then
		Exit Sub
	End If
	If Not WindowInfo(nMID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Exit Sub
	End If
	nLayer	= MapperInfo(nMID, MAPPER_INFO_EDIT_LAYER)
	If nLayer = 0 Then
		Exit Sub
	End If

	msBaseTab		= LayerInfo(nMID, nLayer, LAYER_INFO_NAME)
	sNodesFile	= TableInfo(msBaseTab, TAB_INFO_TABFILE)
	sNodesFile	= Left$(sNodesFile, Len(sNodesFile) - 4) & " Nodes.tab"
	sNodesTab		= PathToTableName$(sNodesFile)

	If Not TABIsOpen(sNodesTab) Then
		Note "Nodes table for the editable layer '" & msBaseTab & "' isn't open: '" & sNodesTab & "'. Please make sure you have a nodes table for the editable layer!"
		Exit Sub
	End If

	If Not DLGUpdateZMUsingNodes(msBaseTab, sNodesTab) Then
		Exit Sub
	End If

'	If Not Ask("This process will update the nodes on the objects in the editable layer  '" & msBaseTab & "' with the MZ values from the points in the nodes layer.", "Continue", "Abort") Then
'		Exit Sub
'	End If

	Select *
		From sNodesTab
		Order By OBJECT_ID, SEGMENT_ID, NODE_ID
		Into __NODES__SORTED NoSelect Hide

	mnRowIDBasePrev	= 0

	Set Table msBaseTab Redraw Off

	If DLGUZMUNUpdateUsing() = UPDATE_USING_OBJECT Then
		Progressbar "Updating Nodes using Object from Nodes Table..."
			Calling DTUpdateZMUsingNodesObject_Single
			Range TableInfo(sNodesTab, TAB_INFO_NROWS)
	Else
		Progressbar "Updating Nodes using Columns from Nodes Table..."
			Calling DTUpdateZMUsingNodesColumn_Single
			Range TableInfo(sNodesTab, TAB_INFO_NROWS)
	End If

	Set Table msBaseTab Redraw On

	Close Table __NODES__SORTED

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMUsingNodesTable")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTUpdateZMUsingNodesObject_Single

Dim	nRowIDNodes, nRowIDBase, nSegment, nNode As Integer,
	fX, fY, fZ, fM As Float,
	oNode As Object,
	aBaseObj As Alias

OnError GoTo ErrorOccured

	aBaseObj		= msBaseTab & ".OBJ"

	nRowIDNodes	= __NODES__SORTED.ROWID
	nRowIDBase	= __NODES__SORTED.OBJECT_ID
'	If nRowIDNodes Mod 100 = 1 Then
'		Call DEBUGPrint("Node RowID: " & FormatNumber$(nRowIDNodes) & ", Polygon RowID: " & FormatNumber$(nRowIDBase))
'	End If

	If Not mnRowIDBasePrev = nRowIDBase Then
		If mnRowIDBasePrev > 0 Then
'			Call DEBUGPrint("Updating RowID " & FormatNumber$(mnRowIDBasePrev))
			Update msBaseTab
				Set OBJ = moBase
				Where ROWID = mnRowIDBasePrev
		End If
		OnError Goto FetchRecordError
		Fetch Rec nRowIDBase From msBaseTab
		OnError Goto ErrorOccured
		moBase = aBaseObj
		mnRowIDBasePrev = nRowIDBase
	End If

	nSegment	= __NODES__SORTED.SEGMENT_ID
	nNode	= __NODES__SORTED.NODE_ID
	oNode	= __NODES__SORTED.OBJ

	If ObjectInfo(moBase, OBJ_INFO_NPOLYGONS) >= nSegment Then
		If ObjectInfo(moBase, OBJ_INFO_NPOLYGONS + nSegment) >= nNode Then
'			If DLGUZMUNUpdateValue("XY") Then
'				fX	= CentroidX(oNode)
'				fY	= CentroidY(oNode)
'			Else
				fX	= ObjectNodeX(moBase, nSegment, nNode)
				fY	= ObjectNodeY(moBase, nSegment, nNode)
'			End If
			If ObjectInfo(oNode, OBJ_INFO_HAS_Z) Then
				fZ	= ObjectGeography(oNode, OBJ_GEO_POINTZ)
			Else
				fZ	= 0
			End If
			If ObjectInfo(oNode, OBJ_INFO_HAS_M) Then
				fM	= ObjectGeography(oNode, OBJ_GEO_POINTM)
			Else
				fM	= 0
			End If

			Alter Object moBase
				Node Set Position nSegment, nNode (fX, fY, fZ, fM)
		End If
	End If

'-------------------------
NextRecord:

	Fetch Next From __NODES__SORTED

	If EOT(__NODES__SORTED) Then
		If mnRowIDBasePrev > 0 Then
			Update msBaseTab
				Set OBJ = moBase
				Where ROWID = mnRowIDBasePrev
		End If
		Progressbar = -1
	Else
		Progressbar = nRowIDNodes
	End If

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMUsingNodesColumn_Single")
	Call ERRPrint()
	GoTo NextRecord

	Exit Sub
'-------------------------
FetchRecordError:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMUsingNodesColumn_Single")
	Call ERRPrint()
	GoTo NextRecord

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTUpdateZMUsingNodesColumn_Single

Dim	nRowIDNodes, nRowIDBase, nSegment, nNode As Integer,
	fX, fY, fZ, fM As Float,
	oNode As Object,
	aBaseObj, aZ, aM As Alias

OnError GoTo ErrorOccured

	aBaseObj		= msBaseTab & ".OBJ"

	nRowIDNodes	= __NODES__SORTED.ROWID
	nRowIDBase	= __NODES__SORTED.OBJECT_ID
	If DLGUZMUNUpdateValue("Z") Then
		aZ			= "__NODES__SORTED." & DLGUZMUNGetColumn("Z")
	End If
	If DLGUZMUNUpdateValue("M") Then
		aM			= "__NODES__SORTED." & DLGUZMUNGetColumn("M")
	End If

	If Not mnRowIDBasePrev = nRowIDBase Then
		If mnRowIDBasePrev > 0 Then
'			Call DEBUGPrint("Updating RowID " & FormatNumber$(mnRowIDBasePrev))
			Update msBaseTab
				Set OBJ = moBase
				Where ROWID = mnRowIDBasePrev
		End If

		OnError Goto FetchRecordError
		Fetch Rec nRowIDBase From msBaseTab
		OnError Goto ErrorOccured
		moBase = aBaseObj
		mnRowIDBasePrev = nRowIDBase
	End If

	nSegment	= __NODES__SORTED.SEGMENT_ID
	nNode	= __NODES__SORTED.NODE_ID
	oNode	= __NODES__SORTED.OBJ

	If ObjectInfo(moBase, OBJ_INFO_NPOLYGONS) >= nSegment Then
		If ObjectInfo(moBase, OBJ_INFO_NPOLYGONS + nSegment) >= nNode Then
'			If DLGUZMUNUpdateValue("XY") Then
'				fX	= CentroidX(oNode)
'				fY	= CentroidY(oNode)
'			Else
				fX	= ObjectNodeX(moBase, nSegment, nNode)
				fY	= ObjectNodeY(moBase, nSegment, nNode)
'			End If
			If DLGUZMUNUpdateValue("Z") Then
				fZ	= aZ
			End If
			If DLGUZMUNUpdateValue("M") Then
				fM	= aM
			End If

'			If ObjectInfo(oNode, OBJ_INFO_HAS_Z) Then
'				fZ	= ObjectGeography(oNode, OBJ_GEO_POINTZ)
'			Else
'				fZ	= 0
'			End If
'			If ObjectInfo(oNode, OBJ_INFO_HAS_M) Then
'				fM	= ObjectGeography(oNode, OBJ_GEO_POINTM)
'			Else
'				fM	= 0
'			End If

			Alter Object moBase
				Node Set Position nSegment, nNode (fX, fY, fZ, fM)
		End If
	End If

'-------------------------
NextRecord:

	Fetch Next From __NODES__SORTED

	If EOT(__NODES__SORTED) Then
		If mnRowIDBasePrev > 0 Then
			Update msBaseTab
				Set OBJ = moBase
				Where ROWID = mnRowIDBasePrev
		End If
		Progressbar = -1
	Else
		Progressbar = nRowIDNodes
	End If

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMUsingNodesColumn_Single")
	Call ERRPrint()
	GoTo NextRecord

	Exit Sub
'-------------------------
FetchRecordError:
	Call ERRCreate(Err(), Error$(), "DTUpdateZMUsingNodesColumn_Single")
	Call ERRPrint()
	GoTo NextRecord

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTOffsetXYZSelection

Dim	sQuery, sUnits, sTempFile, sBaseTab As String,
	nMID, i As Integer,
	fX1, fY1, fX2, fY2, fOffsetX, fOffsetY, fOffsetZ As Float

OnError GoTo ErrorOccured

	nMID	= MAPFrontWindow()
	If nMID = 0 Then
		Note "Please use the tool in the active map window!"
		Exit Sub
	End If

	Set CoordSys Window nMID
	fX1	= CommandInfo(CMD_INFO_X)
	fY1	= CommandInfo(CMD_INFO_Y)
	fX2	= CommandInfo(CMD_INFO_X2)
	fY2	= CommandInfo(CMD_INFO_Y2)

	sUnits	= MapperInfo(nMID, MAPPER_INFO_DISTUNITS)

	If not DLGOXYZCalculationMethodInitiated() Then
		Call DLGOXYZSetCalculationMethod(CALC_METHOD_CARTESIAN)	'CALC_METHOD_SPHERICAL
	End If

	Do Case DLGOXYZCalculationMethod()
		Case CALC_METHOD_SPHERICAL
			fOffsetX	= Distance(fX1, fY1, fX2, fY1, sUnits)
			fOffsetY	= Distance(fX1, fY1, fX1, fY2, sUnits)
		Case Else
			fOffsetX	= CartesianDistance(fX1, fY1, fX2, fY1, sUnits)
			fOffsetY	= CartesianDistance(fX1, fY1, fX1, fY2, sUnits)
	End Case

	fOffsetX	= IIf(fX1 < fX2, fOffsetX, -1 * fOffsetX)
	Call DLGOXYZSetOffsetDistance("X", fOffsetX)
	fOffsetY	= IIf(fY1 < fY2, fOffsetY, -1 * fOffsetY)
	Call DLGOXYZSetOffsetDistance("Y", fOffsetY)

	sQuery	= SelectionInfo(SEL_INFO_SELNAME)
	sBaseTab	= SelectionInfo(SEL_INFO_TABLENAME)

	If Not DLGOffsetXYZ(sUnits) Then
		Close Table sQuery
		Exit Sub
	End If

	fOffsetX	= DLGOXYZOffsetDistance("X")
	fOffsetY	= DLGOXYZOffsetDistance("Y")
	fOffsetZ	= DLGOXYZOffsetDistance("Z")

	If DLGOXYZCreateCopies() Then
		sTempFile	= PathToDirectory$(TempFileName$("")) & "__to_copy.tab"
		If TableInfo(sBaseTab, TAB_INFO_SUPPORT_MZ) Then
			Commit Table sQuery
				As sTempFile SupportMZ On
		Else
			Commit Table sQuery
				As sTempFile
		End If
		Open Table sTempFile

		For i = 1 To DLGOXYZOffsetTimes()
			Set Progressbars Off
			Update __to_copy
				Set OBJ = OBJMZOffsetXYZ(OBJ, fOffsetX, fOffsetY, fOffsetZ, sUnits, DLGOXYZCalculationMethod())
			Commit Table __to_copy
			Set Progressbars On
			Insert Into sBaseTab
				Select * From __to_copy
		Next

		Drop Table __to_copy
	Else
		Update sQuery
			Set OBJ = OBJMZOffsetXYZ(OBJ, fOffsetX, fOffsetY, fOffsetZ, sUnits, DLGOXYZCalculationMethod())
	End If

	Close Table sQuery

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTOffsetXYZSelection")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTCreateCells

Dim	sCmd As String,
	bCreateAnnulusSector, sCoordSys As String

OnError GoTo ErrorOccured

	If Not DLGCreateCell() Then
		Exit Sub
	End If

	sCmd = "Update " & DLGCCGetTable()
			& " Set OBJ = "


'	OBJCreateAnnulusSector( oCenter
'						, fDirection As Float			'360 degrees
'						, fRadiusInner As Float			'meters
'						, fRadiusOuter As Float			'meters
'						, fAngleWidth As Float			' > 0 AND < 360
'						, nResolution As Integer		'A value between 3 and 500, number of nodes to describe a 360 full circle
'						, nCalculationMethod As Integer	'CALC_METHOD_CARTESIAN / CALC_METHOD_SPHERICAL
'						) As Object
'	OBJCreateCircularSector( oCenter As Object
'						, fDirection As Float			'360 degrees
'						, fRadius As Float				'meters
'						, fAngleWidth As Float			' > 0 AND < 360
'						, nResolution As Integer		'A value between 3 and 500, number of nodes to describe a 360 full circle
'						, nCalculationMethod As Integer	'CALC_METHOD_CARTESIAN / CALC_METHOD_SPHERICAL
'						) As Object

	bCreateAnnulusSector	= DLGCCGetInnerRadiusType() = DLGCC_USE_VALUE And DLGCCGetValue(TYPE_INNER_RADIUS) = 0

	If bCreateAnnulusSector Then
		sCmd = sCmd & "DTCreateAnnulusSector("
	Else
		sCmd = sCmd & "DTCreateCircularSector("
	End If

	If DLGCCGetCenterType() = DLGCC_USE_OBJECT Then
		sCmd = sCmd & "OBJ "
	Else
		sCmd = sCmd & "CreatePoint(" & DLGCCGetColumnName(TYPE_CENTERX) & ", " & DLGCCGetColumnName(TYPE_CENTERY) & ") "
	End If

	If DLGCCGetDirectionType() = DLGCC_USE_VALUE Then
		If DLGCCGetAngleType() = DLGCC_ANGLE_TYPE_BEARING Then
			sCmd = sCmd & ", DTNorth2MathAngle(" & Str$(DLGCCGetValue(TYPE_DIRECTION)) & ")"
		Else
			sCmd = sCmd & ", " & Str$(DLGCCGetValue(TYPE_DIRECTION))
		End If
	Else
		If DLGCCGetAngleType() = DLGCC_ANGLE_TYPE_BEARING Then
			sCmd = sCmd & ", DTNorth2MathAngle(" & DLGCCGetColumnName(TYPE_DIRECTION) & ")"
		Else
			sCmd = sCmd & ", " & DLGCCGetColumnName(TYPE_DIRECTION)
		End If
	End If


	If bCreateAnnulusSector Then
		If DLGCCGetInnerRadiusType() = DLGCC_USE_VALUE Then
			sCmd = sCmd & ", " & Str$(DLGCCGetValue(TYPE_INNER_RADIUS))
		Else
			sCmd = sCmd & ", " & DLGCCGetColumnName(TYPE_INNER_RADIUS)
		End If
	End If

	If DLGCCGetOuterRadiusType() = DLGCC_USE_VALUE Then
		sCmd = sCmd & ", " & Str$(DLGCCGetValue(TYPE_OUTER_RADIUS))
	Else
		sCmd = sCmd & ", " & DLGCCGetColumnName(TYPE_OUTER_RADIUS)
	End If

	If DLGCCGetWidthType() = DLGCC_USE_VALUE Then
		sCmd = sCmd & ", " & Str$(DLGCCGetValue(TYPE_WIDTH))
	Else
		sCmd = sCmd & ", " & DLGCCGetColumnName(TYPE_WIDTH)
	End If

	sCmd = sCmd & ", " & Str$(DLGCCGetResolution())
			& ", " & Str$(DLGCCGetCalculationMethod())
			& ")"

	Call DEBUGPrint(sCmd)
	sCoordSys	= SessionInfo(SESSION_INFO_COORDSYS_CLAUSE)
	Run Command "Set Coordsys Table " & DLGCCGetTable()
	Run Command sCmd
	Run Command "Set " & sCoordSys

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTCreateCells")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTDrawAndExtendPolyline

Dim	oDrawnPline, oSegment, oToPline, oNewLine, oShortestLine As Object,
	fX, fY, fTolerance, fShortestLength As Float,
	nWID, nNumPnts, nFromStartOrEnd, nNode As Integer,
	sTab As String

OnError GoTo ErrorOccured

	nWID = FrontWindow()
	If nWID = 0 Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If
	If Not WindowInfo(nWID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If

	sTab	= MAPGetEditLayerName(nWID)
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If
	Set CoordSys Table sTab

	fTolerance	= 10	'meters

	oDrawnPline	= CommandInfo(CMD_INFO_CUSTOM_OBJ)

	For nFromStartOrEnd = 1 To 2
		oNewLine	= OBJCreateLineExtension(oDrawnPline, IIf(nFromStartOrEnd = 1, OBJ_FIRST_SEGMENT, OBJ_LAST_SEGMENT), fTolerance, "m", CALC_METHOD_CARTESIAN)
		Select * From sTab
			Where OBJ Intersects oNewLine
			Into __Extent_To NoSelect Hide

'		Print nFromStartOrEnd & " Found " & TableInfo(__Extent_To, TAB_INFO_NROWS) & " records from tables ROADS"

		fShortestLength	= fTolerance * 10
		Fetch First From __Extent_To
		Do Until EOT(__Extent_To)
			oToPline	= __Extent_To.OBJ

			oNewLine	= OBJCreateLineToIntersection(oDrawnPline, IIf(nFromStartOrEnd = 1, OBJ_FIRST_SEGMENT, OBJ_LAST_SEGMENT), oToPline, fTolerance, "m", CALC_METHOD_CARTESIAN)
			If not ObjectInfo(oNewLine, OBJ_INFO_TYPE) = OBJ_TYPE_POINT Then
				If CartesianObjectLen(oNewLine, "m") < fShortestLength Then
					fShortestLength 	= CartesianObjectLen(oNewLine, "m")
					oShortestLine		= oNewLine
				End If
			End If
			Fetch Next From __Extent_To
		Loop

		If fShortestLength < (fTolerance * 10) Then
			fX		= ObjectNodeX(oShortestLine, 1, 2)
			fY		= ObjectNodeY(oShortestLine, 1, 2)
			nNode	= IIf(nFromStartOrEnd = 1, 1, ObjectInfo(oDrawnPline, OBJ_INFO_NPOLYGONS + 1))
			Alter Object oDrawnPline
				Node Set Position 1, nNode (fX, fY)
		End If

		Close Table __Extent_To
	Next

	Insert Into sTab (OBJ) Values (oDrawnPline)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTDrawAndExtendPolyline")
	Call ERRShow()

End Sub

'**********************************************************************************************''
'Created by Peter Horsbøll Møller, Precisely
'Parameters:
'
'**********************************************************************************************''
Sub DTDrawPointBuffer

Dim	nWID, nCalculationMethod As Integer,
	fStartX, fStartY, fEndX, fEndY, fDistance As Float,
	sTab As String,
	oPoint, oGeometry As Object

OnError GoTo ErrorOccured

	nWID = FrontWindow()
	If nWID = 0 Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If
	If Not WindowInfo(nWID, WIN_INFO_TYPE) = WIN_MAPPER Then
		Note "Please use this tool in a map window!"
		Exit Sub
	End If

	sTab	= MAPGetEditLayerName(nWID)
	If sTab = "" Then
		Note "Please make sure that you have made a layer editable!"
		Exit Sub
	End If
	Set CoordSys Table sTab

	fStartX	= CommandInfo(CMD_INFO_X)
	fStartY	= CommandInfo(CMD_INFO_Y)
	fEndX	= CommandInfo(CMD_INFO_X2)
	fEndY	= CommandInfo(CMD_INFO_Y2)

'	Note FormatNumber$(fStartX) & " | " & FormatNumber$(fStartY)

	fDistance			= Round(CartesianDistance(fStartX, fStartY, fEndX, fEndY, "m"), 0.001)
	nCalculationMethod	= CALC_METHOD_CARTESIAN

'	Note FormatNumber$(fDirection) & " | " & FormatNumber$(fDistance)
	If fDistance = -1 Then
		fDistance			= Round(Distance(fStartX, fStartY, fEndX, fEndY, "m"), 0.001)
		nCalculationMethod	= CALC_METHOD_SPHERICAL
	End If

'	If Not DLGPointBuffer(fStartX, fStartY, fDistance, -1, -1, -1) Then
'		Exit Sub
'	End If

'	oPoint	= CreatePoint(DLGITGetX(), DLGITGetY())
'	oGeometry = CartesianBuffer(oPoint, DLGPBGetRadius(), DLGPBGetResolution(), DLGPBGetCalculationMethod())
	oPoint	= CreatePoint(fStartX, fStartY)
	If nCalculationMethod = CALC_METHOD_CARTESIAN Then
		oGeometry = CartesianBuffer(oPoint, 36, fDistance, "m")
	Else
		oGeometry = Buffer(oPoint, 36, fDistance, "m")
	End If

	Insert Into sTab (OBJ) Values (oGeometry)

	Exit Sub
'-------------------------
ErrorOccured:
	Call ERRCreate(Err(), Error$(), "DTDrawPointBuffer")
	Call ERRShow()

End Sub

